# Правила разработки и качества кода

> Цель этого документа — обеспечить устойчивое качество кода, воспроизводимость решений и единые подходы к тестированию и документации. Следуйте правилам **обязательно**.

## 1. Общие принципы

- **Качество важнее скорости.** Любое изменение должно быть понятным, тестируемым и документированным.
- **Повторяемость.** Все решения должны быть воспроизводимы (скрипты, команды, описания).
- **Прозрачность.** Любая новая логика сопровождается документацией и тестами.
- **Минимизация технического долга.** Если что-то нельзя сделать «правильно» сейчас — фиксируйте это в TODO с датой и ссылкой на задачу.

## 2. Структура проекта и правила размещения кода

- **Компоненты UI** размещаются в `src/components/ui/`.
- **Сложные компоненты/виды** — в `src/views/`.
- **Композиции** — в `src/composables/`.
- **Маршруты** — в `src/router/`.
- **Утилиты** — в `src/utils/`.
- **Стили** — в `src/assets/styles/` (не дублируйте стили локально без необходимости).

## 3. Именование и соглашения

### Файлы и папки

- **Компоненты**: `PascalCase.vue` (например, `UserCard.vue`).
- **Композиции**: `useXxx.ts` (например, `useTheme.ts`).
- **Утилиты**: `camelCase.ts`.
- **Тесты**: `ComponentName.spec.ts` или `useXxx.spec.ts`.

### Переменные и функции

- `camelCase` для переменных и функций.
- Константы: `UPPER_SNAKE_CASE`.
- Избегайте сокращений, кроме общепринятых (`id`, `url`).

## 4. Документация (обязательна)

Каждое изменение **должно** сопровождаться документацией:

- **Новый компонент**: добавьте описание в `src/components/ui/README.md` и/или `README.md`.
- **Новая функция/композиция/утилита**: добавьте описание в соответствующий раздел документации.
- **Пример использования** обязателен.

### JSDoc (обязателен для методов)

Для каждой новой функции/метода пишите JSDoc на русском языке.

Пример:

```ts
/**
 * Форматирует отображаемое имя пользователя.
 * @param firstName Имя пользователя.
 * @param lastName Фамилия пользователя.
 * @returns Полное имя, собранное через пробел.
 */
export const formatUserName = (firstName: string, lastName: string): string => {
  return `${firstName} ${lastName}`
}
```

## 5. Компоненты и интерфейсы

### Обязательные требования

- Каждый компонент должен иметь **описание**, **примеры использования** и **перечень пропсов**.
- Все публичные события (`emit`) документируются.
- Пропсы должны быть строго типизированы.
- Используйте `defineProps`/`defineEmits` с `interface` или `type`.

### Пример документации компонента

````md
## UIInput

### Описание

Поле ввода с поддержкой метки, подсказок и ошибок.

### Пропсы

| Имя        | Тип    | Обязательный | По умолчанию | Описание              |
| ---------- | ------ | ------------ | ------------ | --------------------- |
| modelValue | string | да           | —            | Текущее значение поля |
| label      | string | нет          | —            | Текст метки           |

### События

| Событие           | Тип    | Описание                           |
| ----------------- | ------ | ---------------------------------- |
| update:modelValue | string | Срабатывает при изменении значения |

### Пример

```vue
<UIInput v-model="name" label="Имя" />
```
````

## 6. Тестирование (обязательно)

### Минимальные требования

- **Новая функциональность** = **новые тесты**.
- **Исправление бага** = **тест, который воспроизводит баг**.
- Тест должен быть понятен без чтения кода функции.

### Что тестируем

- Логику в `composables/` и `utils/`.
- Компоненты UI — через поведенческие тесты (`Testing Library`).
- Бизнес-сценарии (логика использования) в `views` или специализированных тестах.

### Пример теста

```ts
import { describe, expect, it } from 'vitest'

describe('formatUserName', () => {
  it('собирает имя и фамилию через пробел', () => {
    expect(formatUserName('Иван', 'Иванов')).toBe('Иван Иванов')
  })
})
```

## 7. Качество кода

### Общие правила

- Следуйте настройкам `ESLint`, `Stylelint`, `Prettier`.
- Не отключайте правила линтера для обхода ошибок.
- Избегайте «магических чисел» — используйте именованные константы.
- Разбивайте сложные участки на мелкие функции.

### Пример читаемой функции

```ts
/**
 * Проверяет, является ли пользователь активным.
 * @param status Статус пользователя.
 * @returns `true`, если пользователь активен.
 */
export const isUserActive = (status: string): boolean => {
  return status === 'active'
}
```

## 8. Архитектура и границы ответственности

- Логика не должна быть в шаблоне компонента — выносите в `setup` и `composables`.
- Компоненты UI не должны знать о бизнес-логике.
- `views/` могут объединять UI и бизнес-логику через композиции.

## 9. Работа с состоянием (Pinia)

- Состояние группируется по доменам.
- Не храните в состоянии то, что можно вычислить (`computed`).
- В сторе описывайте `state`, `getters`, `actions`.
- Внешние сервисы (API) используйте через отдельные слои (например, `services/`).

## 10. Работа с API

- Все запросы должны быть вынесены в отдельные модули.
- Ошибки обрабатываются централизованно.
- Для моделей данных используйте типы или интерфейсы.

## 11. Коммиты и ревью

### Коммиты

- Один логический коммит = одно изменение.
- Сообщения коммитов должны быть понятными и описывать цель.

Пример:

```
feat: add documentation rules for new components
```

### Ревью

- Перед отправкой PR убедитесь, что:
  - ✅ код покрыт тестами;
  - ✅ документация обновлена;
  - ✅ форматирование и линтинг пройдены.

## 12. Локальные проверки перед PR

Всегда выполняйте:

```bash
npm run format
npm run lint
npm run test
```

## 13. Требования к обновлению документации

После каждого изменения:

- Обновите `README.md`, если это влияет на архитектуру, структуру или публичные API.
- Обновите документацию компонентов или модулей.
- Добавьте или уточните примеры.

## 14. Контроль качества и ответственность

- Любая новая функциональность без тестов и документации считается **непринятой**.
- Сложная логика без объяснения — **ошибка**.
- Технический долг должен быть зафиксирован явно и согласован.

---

Если у вас есть сомнения, как правильно оформить изменение — **остановитесь** и уточните у команды, прежде чем продолжать.
